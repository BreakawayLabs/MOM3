#if defined obc_south || defined obc_north
# define obc1
#endif
#if defined obc_west || defined obc_east
# define obc2
#endif
#ifdef makeobcpsi
      program mkobcpsi
c
c-----------------------------------------------------------------------
c     prepare stream function data at
c     northern and southern open boundaries.
c
c     If option "readferret" is set, open boundary data will be read
c     from an external file, written by FERRET. Subroutine "readpsi"
c     has to be adapted.
c     If the above option is not set data have to build in directly in
c     the code.
c
c     author:   Arne Biastoch   e-mail: abiastoch@ifm.uni-kiel.de
c-----------------------------------------------------------------------
c
#include "size.h"
#include "pconst.h"
      integer stdout, stdin
      parameter (stdout=6, stdin=5)
c
      character*32 stamp
      character*80 iotext
c
      dimension dxtdeg(imt), dytdeg(jmt), dzt(km)
      dimension dxudeg(imt), dyudeg(jmt), dzw(0:km)
      dimension xt(imt),xu(imt),yt(jmt),yu(jmt),zt(km),zw(km)
      dimension dyt(jmt), hr(jmt)
c
      dimension psiwall_south(imt), psiwall_north(imt)
      dimension psiwall_west(jmt),  psiwall_east(jmt)
c      
      dimension uwall_west(jmt),  uwall_east(jmt)
c
      common/ic/ kmt(imt,jmt)
c
c-----------------------------------------------------------------------
c     initialize the i/o units
c-----------------------------------------------------------------------
c
      call ioinit
#ifdef obc1      
      call getunit (iosp1,  'obcpsi1.mom'
     &,             'unformatted sequential append ieee')
#endif
#ifdef obc2
      call getunit (iosp2,  'obcpsi2.mom'
     &,             'unformatted sequential append ieee')
#endif
#ifdef readferret
# ifdef obc_south
      call getunit (ioget1, 'obc_psi_south.dat'
     &,             'formatted sequential rewind')
# endif
# ifdef obc_north
      call getunit (ioget2, 'obc_psi_north.dat'
     &,             'formatted sequential rewind')
# endif
# ifdef obc_west
      call getunit (ioget3, 'obc_psi_west.dat'
     &,             'formatted sequential rewind')
# endif
# ifdef obc_east
      call getunit (ioget4, 'obc_psi_east.dat'
     &,             'formatted sequential rewind')
# endif
#endif
c
c-----------------------------------------------------------------------
c     construct the grid.
c-----------------------------------------------------------------------
c
      write (stdout,'(//1x,a,//)') 'Construct the MOM grid'
c
      maxlen = max(imt,jmt,km)
      call gcoord (maxlen, iimt, ijmt, ikm, dxtdeg, dytdeg, dxudeg
     &,            dyudeg, dzt, dzw, xt, xu, yt, yu, zt, zw)
c
      if (imt .ne. iimt .or. jmt .gt. ijmt .or. km .gt. ikm) then
        write (stdout,*) ' => parameter mismatch in mkobc'
	write (stdout,*) 'imt=',imt,' iimt=',iimt
	write (stdout,*) 'jmt=',jmt,' ijmt=',ijmt
	write (stdout,*) 'km=',km,' ikm=',ikm
	stop '=> mkobcpsi'
      endif
c
c-----------------------------------------------------------------------
c     generate the kmt field on the grid defined by grids.F
c-----------------------------------------------------------------------
c
      call getunit (iokmt, 'kmt.dta'
     &,             'unformatted sequential rewind ieee')
      call read_kmt (iokmt)
c      
c     write (stdout,'(/,20x,a/)') ' Driving the topog module...'
c     call topog (kmt, map, xt, yt, zt, xu, yu, zw, iimt, ijmt, ikm)
c
      pi     = c4*atan(c1)
      radian = c360/(c2*pi)
      radius = 6370.0e5
      degtcm = radius/radian
      do jrow=1,jmt
        dyt(jrow) = dytdeg(jrow)*degtcm
      enddo
c
c-----------------------------------------------------------------------
c     initialize
c-----------------------------------------------------------------------
c
        do i=1,imt
          psiwall_south(i) = 0.
          psiwall_north(i) = 0.
        enddo
        do j=1,jmt
          uwall_west(j)   = 0.
          uwall_east(j)   = 0.
          psiwall_west(j) = 0.
          psiwall_east(j) = 0.
        enddo
c
#ifdef readferret
c-----------------------------------------------------------------------
c     read input generated by FERRET
c-----------------------------------------------------------------------
c
# ifdef obc_south
      call readpsi(ioget1, imt, psiwall_south)
# endif
# ifdef obc_north
      call readpsi(ioget2, imt, psiwall_north)
# endif
# ifdef obc_west
      call readpsi(ioget3, jmt, psiwall_west)
# endif
# ifdef obc_east
      call readpsi(ioget4, jmt, psiwall_east)
# endif
#else
c
      write (stdout,'(//1x,a,//)')  
     & 'The data have to be build in directly into the code'
c
#endif
c
#ifdef write_netcdf
c-----------------------------------------------------------------------
c      write open boundaries in NETCDF file
c-----------------------------------------------------------------------
c
      call  write_netcdf(xt, yt, psiwall_south, psiwall_north,
     &      uwall_west,  uwall_east, psiwall_west,  psiwall_east)
#endif
c
#ifdef obc1
        iotext ='imt, km, jmt, psiwall_south, psiwall_north'
        write (iosp1) iotext
        write (iosp1) imt, km, jmt 
# ifdef obc_south	
     &,              (psiwall_south(i),i=1,imt)	
# endif
# ifdef obc_north	
     &,              (psiwall_north(i),i=1,imt)
# endif
#endif
#ifdef obc2
        iotext ='imt, km, jmt, psiwall_west, psiwall_east'
        write (iosp2) iotext
        write (iosp2) imt, km, jmt, jpsimax, psimax
# ifdef obc_west	
     &,              (psiwall_west(j),j=1,jmt)
# endif
# ifdef obc_east	
     &,              (psiwall_east(j),j=1,jmt)
# endif
#endif
        write (stdout,'(1x,a)')
     &   'Writing OBC '
c
      stop
      end

#define driver_only
#include "iomngr.F"
#include "util.F"
#include "grids.F"
#include "size_check.F"

#else
      subroutine mkobcpsi
      return
      end
#endif

c 
#ifdef write_netcdf 
      subroutine write_netcdf(xt, yt, psiwall_south,psiwall_north 
     & , uwall_west, uwall_east, psiwall_west, psiwall_east) 
c 
      include  'netcdf.inc' 
c 
# include "size.h" 
# include "switch.h" 
# include "tmngr.h" 
c 
      integer  stdin, stdout, stderr 
      parameter (stdin = 5, stdout = 6, stderr = 6) 
c
      character iotext*80,expnam*60 
c 
c error return code and netCDF id 
      integer iret, ncid 
c dimension ids 
      integer Latitude_tdim, Longitude_tdim 
c variable ids 
      integer Longitude_tid, Latitude_tid 
     &, psinid, psisid, psiwid, psieid, uwid, ueid
c variable shapes, corner and edge lengths 
      integer dims(4), corner(4), edges(4) 
c data variables 
      real Latitude_t(jmt), Longitude_t(imt) 
c attribute vectors
      integer longval(1) 
      real floatval(2) 
      character*24 obcname 
      dimension xt(imt),yt(jmt) 
      dimension psiwall_south(imt),psiwall_north(imt) 
      dimension psiwall_west(jmt),psiwall_east(jmt) 
      dimension uwall_west(jmt),uwall_east(jmt) 
c
c-----------------------------------------------------------------------
c define netCDF variables
c-----------------------------------------------------------------------
c 
c enter define mode: NCCLOB=overwrite, NCNOCLOB=don't overwrite 
c 
      ncid = nccre ('obcpsi.cdf', NCCLOB, iret) 
c 
c define dimensions 
c 
      Latitude_tdim = ncddef(ncid, 'Latitude_t', jmt,iret) 
      Longitude_tdim = ncddef(ncid, 'Longitude_t', imt, iret) 
c
c define variables 
c 
      dims(1) = Latitude_tdim 
      Latitude_tid = ncvdef (ncid,'Latitude_t',NCFLOAT,1,dims,iret) 
      dims(1) = Longitude_tdim 
      Longitude_tid = ncvdef(ncid,'Longitude_t',NCFLOAT,1,dims,iret) 
      dims(1) = Longitude_tdim 
#ifdef obc_south 
      psisid = ncvdef(ncid,'psi_south', NCFLOAT,1,dims,iret) 
#endif 
#ifdef obc_north 
      psinid = ncvdef (ncid,'psi_north',NCFLOAT,1,dims,iret) 
#endif 
      dims(1) = Latitude_tdim 
#ifdef obc_west 
      psiwid = ncvdef (ncid,'psi_west',NCFLOAT,1,dims,iret) 
      uwid   = ncvdef (ncid,'u_west',NCFLOAT,1,dims,iret) 
#endif 
#ifdef obc_east 
      psieid = ncvdef(ncid,'psi_east', NCFLOAT,1,dims,iret) 
      ueid   = ncvdef(ncid,'u_east', NCFLOAT,1,dims,iret) 
#endif 
c
c-----------------------------------------------------------------------
c assign attributes
c-----------------------------------------------------------------------
c 
      call ncaptc(ncid, Latitude_tid, 'long_name', NCCHAR, 24,
     &          'Latitude on T grid ', iret) 
      call ncaptc(ncid, Latitude_tid,'units', NCCHAR, 16, 
     & 'degrees_N ', iret) 
      call ncaptc(ncid,Longitude_tid, 'long_name', NCCHAR, 24, 
     & 'Longitude on T grid', iret) 
      call ncaptc(ncid, Longitude_tid, 'units', NCCHAR, 16, 
     &           'degrees_W ', iret) 
c 
#ifdef obc_south 
      if (yt(1).ge.0.) then
        write (obcname,'("PSI AT ",F6.2," N ")') yt(1) 
      else 
        write (obcname,'("PSI AT ",F6.2," S ")') yt(1) 
      endif 
      call ncaptc(ncid,psisid,'long_name',NCCHAR,24,obcname,iret) 
      call ncaptc(ncid,psisid,'units', NCCHAR,16,' cm3/s ', iret) 
#endif 
#ifdef obc_north 
      if (yt(jmt).ge.0.) then
        write (obcname,'("PSI AT ",F6.2," N ")') yt(jmt) 
      else 
        write (obcname,'("PSI AT ",F6.2," S ")') yt(jmt) 
      endif 
      call ncaptc(ncid, psinid,'long_name',NCCHAR,24,obcname,iret) 
      call ncaptc(ncid, psinid,'units', NCCHAR,16,' cm3/s ', iret) 
#endif 
c
#ifdef obc_west 
      if (xt(1).ge.0.) then 
        write (obcname,'("PSI AT ",F6.2," E ")') xt(1) 
      else 
        write (obcname,'("PSI AT ",F6.2," W ")') xt(1) 
      endif 
      call ncaptc(ncid,psiwid,'long_name',NCCHAR,24,obcname,iret) 
      call ncaptc(ncid,psiwid,'units', NCCHAR,16,'cm3/s', iret) 
      floatval(1) = 0.
      call ncapt (ncid,psiwid, 'missing_value',NCFLOAT,1,floatval,iret)
      if (xt(1).ge.0.) then 
        write (obcname,'("U AT ",F6.2," E ")') xt(1) 
      else 
        write (obcname,'("U AT ",F6.2," W ")') xt(1) 
      endif 
      call ncaptc(ncid,uwid,'long_name',NCCHAR,24,obcname,iret) 
#endif 
c 
#ifdef obc_east 
      if (xt(imt).ge.0.) then
        write (obcname,'("PSI AT ",F6.2," W ")') xt(imt) 
      else 
        write (obcname,'("PSI AT ",F6.2," E ")') xt(imt) 
      endif 
      call ncaptc(ncid, psieid,'long_name',NCCHAR,24,obcname,iret) 
      call ncaptc(ncid, psieid,'units', NCCHAR,16,'cm3/s', iret) 
      floatval(1) = 0.
      call ncapt (ncid,psieid, 'missing_value',NCFLOAT,1,floatval,iret)
      if (xt(imt).ge.0.) then
        write (obcname,'("U AT ",F6.2," W ")') xt(imt) 
      else 
        write (obcname,'("U AT ",F6.2," E ")') xt(imt) 
      endif 
      call ncaptc(ncid, ueid,'long_name',NCCHAR,24,obcname,iret) 
#endif 
c
      expnam='OPEN BOUNDARY VALUES' 
      call ncaptc(ncid, NCGLOBAL,'title', NCCHAR, 60, expnam, iret) 
c 
c      call ncaptc(ncid, NCGLOBAL,'history', NCCHAR, 32, 
c     & stamp(itm), iret) 
c
c-----------------------------------------------------------------------
c leave define mode
c-----------------------------------------------------------------------
c 
      call ncendf(ncid, iret) 
c
c-----------------------------------------------------------------------
c convert variables 
c change depth to m 
c put land mask
c-----------------------------------------------------------------------
c 
      do i=1,imt 
        Longitude_t(i)=xt(i) 
      enddo 
      do j=1,jmt
        Latitude_t(j)=yt(j) 
      enddo 
c-----------------------------------------------------------------------
c put variables in netCDF file
c-----------------------------------------------------------------------
c 
c store Longitude_t 
      corner(1) = 1 
      edges(1) = imt 
      call ncvpt(ncid, Longitude_tid, corner, edges, Longitude_t, iret) 
c store Latitude_t 
      corner(1) = 1 
      edges(1) = jmt 
      call ncvpt(ncid,Latitude_tid, corner, edges, Latitude_t, iret) 
c store data
      corner(1) = 1 
      edges(1) = imt 
#ifdef obc_north 
      call ncvpt(ncid,psinid, corner, edges, psiwall_north, iret) 
#endif 
#ifdef obc_south 
      call ncvpt(ncid, psisid, corner, edges, psiwall_north, iret)
#endif 
c store data 
      corner(1) = 1 
      edges(1) = jmt 
#ifdef obc_west 
      call ncvpt(ncid, psiwid, corner, edges, psiwall_west, iret) 
      call ncvpt(ncid, uwid,   corner, edges, uwall_west,   iret) 
#endif 
#ifdef obc_east 
      call ncvpt(ncid, psieid,corner, edges, psiwall_east, iret) 
      call ncvpt(ncid, ueid,  corner, edges, uwall_east,   iret) 
#endif 
c 
      call ncclos (ncid, iret) 
c return 
      end 
#endif 
c 
      subroutine readpsi(ioget, imt, psiwall) 
c 
c reads psi written by FERRET 
c 
      character*70 dummy
      dimension psiwall(imt,2) 
c 
      do l=1,7 
        read(ioget,100) dummy 
100     format(A70) 
      enddo 
c 
      do i=1,imt 
        read(ioget,200) psiwall(i,1),psiwall(i,2) 
200     format(11X,2F7.2) 
      enddo 
c 
      return
      end 

      subroutine read_kmt (iokmt)
#include "size.h"
#include "stdunits.h"
c
      character*32 stamp
      character*80 iotext
      character*60 expnam
      common/ic/ kmt(imt,jmt)
      rewind iokmt
              write (stdout,'(//a/)')
     & ' =>Reading a "kmt" field from file "kmt.dta" '
      read (iokmt) stamp, iotext, expnam
      read (iokmt) imax, jmax, kmax
      if (imax .ne. imt .or. jmax .ne. jmt) then
        write (stdout,*)
     & '=>Error: imt from file "kmt.dta" is ',imax, ' MOM expects ',imt
     &, '        jmt from file "kmt.dta" is ',jmax, ' MOM expects ',jmt
        stop '=> read_kmt in ic'
      else
        read (iokmt) stamp, iotext, expnam
        read (iokmt) kmt
      endif
      write (stdout,'(/,20x,a/)') ' The "kmt" field follows:'
c     call iplot (kmt, imt, imt, jmt)
c
      return
      end
      
